import components.map.Map;
import components.map.Map1L;

/**
 * AniLibrary kernel implemented on an OSU Map1L from title to genre.
 *
 * @convention <pre>
 *  this.rep != null  and
 *  for all t in DOMAIN(this.rep): t != null and this.rep.value(t) != null
 * </pre>
 * @correspondence <pre>
 *  this = { (t, g) | t in DOMAIN(this.rep)  and  g = this.rep.value(t) }
 * </pre>
 */
public class AniLibrary1L extends AniLibrarySecondary {
    /*
     * Private members --------------------------------------------------------
     */

    /**
     * Representation of this as a map title -> genre.
     */
    private Map<String, String> rep;

    /**
     * Creator of initial representation.
     */
    private void createNewRep() {
        this.rep = new Map1L<>();
    }

    /*
     * Constructors -----------------------------------------------------------
     */

    /**
     * No-argument constructor.
     */
    public AniLibrary1L() {
        this.createNewRep();
    }

    /*
     * Standard methods -------------------------------------------------------
     */

    @Override
    public final AniLibrary newInstance() {
        try {
            return this.getClass().getConstructor().newInstance();
        } catch (ReflectiveOperationException e) {
            throw new AssertionError(
                "Cannot construct object of type " + this.getClass());
        }
    }

    @Override
    public final void clear() {
        this.createNewRep();
    }

    @Override
    public final void transferFrom(AniLibrary source) {
        assert source != null : "Violation of: source is not null";
        assert source != this : "Violation of: source is not this";
        assert source instanceof AniLibrary1L : ""
            + "Violation of: source is of dynamic type AniLibrary1L";
        /*
         * This cast cannot fail since the assert above would have stopped
         * execution otherwise.
         */
        AniLibrary1L localSource = (AniLibrary1L) source;
        this.rep = localSource.rep;
        localSource.createNewRep();
    }

    /*
     * Kernel methods ---------------------------------------------------------
     */

    @Override
    public final String[] removeAny() {
        assert this.size() > 0 : "Violation of: this /= {}";
        Map.Pair<String, String> p = this.rep.removeAny();
        return new String[] { p.key(), p.value() };
    }

    @Override
    public final void addSeries(String title, String genre) {
        assert title != null : "Violation of: title is not null";
        assert genre != null : "Violation of: genre is not null";
        assert !this.hasSeries(title) : "Violation of: title not in domain(this)";
        this.rep.add(title, genre);
    }

    @Override
    public final String removeSeries(String title) {
        assert title != null : "Violation of: title is not null";
        assert this.hasSeries(title) : "Violation of: title in domain(this)";
        Map.Pair<String, String> removed = this.rep.remove(title);
        return removed.value();
    }

    @Override
    public final boolean hasSeries(String title) {
        assert title != null : "Violation of: title is not null";
        return this.rep.hasKey(title);
    }

    @Override
    public final String genreOf(String title) {
        assert title != null : "Violation of: title is not null";
        assert this.hasSeries(title) : "Violation of: title in domain(this)";
        return this.rep.value(title);
    }

    @Override
    public final int size() {
        return this.rep.size();
    }
}
